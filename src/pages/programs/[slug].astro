---
import type { GetStaticPathsResult } from "astro";
import ProgramLayout from "../../layouts/ProgramLayout.astro";
import HeroSection from "../../components/HeroSection.astro";
import Section from "../../components/Section.astro";
import SectionHeader from "../../components/SectionHeader.astro";
import ClassCard from "../../components/ClassCard.astro";
import ButtonGroup from "../../components/ButtonGroup.astro";
import { marked } from "marked";
import { getProgramsData, getClassesData, getCategoriesData } from "../../utils/markdown.js";
import type { StructuredContentRecord, StructuredCta } from "../../types/content";

interface RouteProps {
  programData: StructuredContentRecord;
  relatedClasses: StructuredContentRecord[];
  categoryData: StructuredContentRecord[];
}

export async function getStaticPaths(): Promise<GetStaticPathsResult> {
  const programs = getProgramsData();
  const classes = getClassesData();
  const categories = getCategoriesData();
  return programs
    .map((entry) => {
      const slug = entry.meta?.slug ?? entry.slug;
      if (!slug) {
        return undefined;
      }

      const classSlugs = entry.meta?.classes ?? entry.classes ?? [];
      const relatedClasses = classSlugs
        .map((classSlug: string) =>
          classes.find((classItem) => (classItem.meta?.slug ?? classItem.slug) === classSlug),
        )
        .filter(Boolean) as StructuredContentRecord[];

      const categorySlugs = Array.isArray(entry.meta?.category)
        ? entry.meta.category
        : Array.isArray(entry.category)
          ? entry.category
          : [];

      const matchedCategories = categorySlugs
        .map((categorySlug: string) =>
          categories.find(
            (categoryEntry) => (categoryEntry.meta?.slug ?? categoryEntry.slug) === categorySlug,
          ),
        )
        .filter(Boolean) as StructuredContentRecord[];

      return {
        params: { slug },
        props: {
          programData: entry,
          relatedClasses,
          categoryData: matchedCategories,
        },
      };
    })
    .filter(Boolean) as GetStaticPathsResult;
}

const { programData, relatedClasses, categoryData } = Astro.props as unknown as RouteProps;

const programSlug = programData.meta?.slug ?? programData.slug;

if (!programData || !programSlug) {
  throw new Error("Program data not found for requested slug");
}

const heroImageSource = programData.meta?.image ?? programData.image;
const heroImage = heroImageSource
  ? `/images/cards/${heroImageSource}`
  : "/images/cards/programs.png";
const heroAlt = programData.title ?? "Program hero";
const heroDescription = programData.blurb ?? programData.shortDescription;
const descriptionText =
  programData.description || programData.blurb || programData.shortDescription || "";
const descriptionParagraphs = descriptionText
  .split(/\n\s*\n/)
  .map((paragraph) => paragraph.trim())
  .filter((paragraph) => paragraph.length > 0);
const topics = programData.meta?.topics ?? programData.topics ?? [];
const hasContent = Boolean(programData.content && programData.content.trim().length > 0);
const renderedContent = hasContent ? await marked.parse(programData.content ?? "") : undefined;
const programEnrollContent =
  typeof programData.enroll === "string" ? programData.enroll.trim() : "";
const categoryEntries = Array.isArray(categoryData) ? categoryData : [];
const categoryEnrollSections = categoryEntries
  .map((entry) => (typeof entry.enroll === "string" ? entry.enroll.trim() : ""))
  .filter((content) => content.length > 0);
const categoryCtas = categoryEntries.flatMap((entry) => {
  if (Array.isArray(entry.cta)) {
    return entry.cta;
  }
  if (Array.isArray(entry.meta?.cta)) {
    return entry.meta?.cta as StructuredCta[];
  }
  return [];
});
const sanitizedCategoryCtas = categoryCtas.filter(
  (action): action is StructuredCta => Boolean(action?.label && action?.url),
);
const programCtas = Array.isArray(programData.cta)
  ? (programData.cta as StructuredCta[])
  : Array.isArray(programData.meta?.cta)
    ? (programData.meta.cta as StructuredCta[])
    : [];
const sanitizedProgramCtas = programCtas.filter(
  (action): action is StructuredCta => Boolean(action?.label && action?.url),
);
const resolvedCtas =
  sanitizedProgramCtas.length > 0 ? sanitizedProgramCtas : sanitizedCategoryCtas;
const effectiveEnrollContent =
  programEnrollContent || categoryEnrollSections.find((content) => content.length > 0) || "";
const hasEnrollSection = Boolean(effectiveEnrollContent) || resolvedCtas.length > 0;
---

<ProgramLayout
  title={programData.title}
  description={heroDescription ?? programData.description}
>
  <HeroSection slot="hero" class="program-hero">
    <h1 slot="tagline">{programData.title}</h1>
    {(heroDescription || topics.length > 0) && (
      <div slot="description" class="program-hero__description">
        {heroDescription && <p class="program-hero__lead">{heroDescription}</p>}
        {topics.length > 0 && (
          <div class="program-hero__topics">
            {topics.map((topic) => (
              <span class="topic-pill">{topic}</span>
            ))}
          </div>
        )}
      </div>
    )}
    <div slot="media" class="program-hero__media">
      <img src={heroImage} alt={`${heroAlt} illustration`} loading="eager" />
    </div>
  </HeroSection>

  <Section startBgcolor="var(--color-surface)" endBgcolor="var(--color-surface-alt)">
    <SectionHeader>
      <h2>Program Overview</h2>
    </SectionHeader>

    <div class="program-content">
      {renderedContent ? (
        <div class="program-content__body" set:html={renderedContent} />
      ) : descriptionParagraphs.length > 0 ? (
        descriptionParagraphs.map((paragraph) => <p>{paragraph}</p>)
      ) : (
        <p>Additional program details will be published soon.</p>
      )}
    </div>
  </Section>

  {relatedClasses.length > 0 && (
    <Section startBgcolor="var(--color-surface-alt)" endBgcolor="var(--color-primary-soft)">
      <SectionHeader>
        <h2>Classes in this Program</h2>
        <p>Explore the classes that are part of this program pathway.</p>
      </SectionHeader>

      <div class="program-classes">
        {relatedClasses
          .map((classItem) => {
            const classSlug = classItem.meta?.slug ?? classItem.slug;
            const classImage = classItem.meta?.image ?? classItem.image;
            const classLevel = classItem.meta?.level ?? classItem.level;

            if (!classSlug || !classImage) {
              console.warn(`Related class "${classItem.title}" is missing slug or image.`);
              return null;
            }

            return (
              <ClassCard
                img={`/images/cards/${classImage}`}
                alt={classItem.title}
                slug={classSlug}
                title={classItem.title}
                level={classLevel}
                description={classItem.blurb ?? classItem.description ?? ""}
              />
            );
          })
          .filter(Boolean)}
      </div>
    </Section>
  )}

  {hasEnrollSection && (
    <Section
      startBgcolor="var(--color-surface-alt)"
      endBgcolor="var(--color-primary-soft)"
      class="program-enroll-section"
    >
      <SectionHeader>
        <h2>How to Enroll</h2>
      </SectionHeader>

      <div class="program-enroll">
        {effectiveEnrollContent && (
          <div
            class="program-enroll__text program-enroll__text--program"
            set:html={effectiveEnrollContent}
          />
        )}

        {resolvedCtas.length > 0 && (
          <ButtonGroup
            class="program-enroll__buttons"
            actions={resolvedCtas.map((action: StructuredCta) => {
              const isExternal = action.url ? /^https?:/i.test(action.url) : false;
              return {
                label: action.label ?? "Enroll",
                href: action.url ?? "#",
                variant: "primary",
                target: isExternal ? "_blank" : undefined,
                rel: isExternal ? "noopener noreferrer" : undefined,
              };
            })}
          />
        )}
      </div>
    </Section>
  )}
</ProgramLayout>

<style>
  .program-hero__description {
    display: grid;
    gap: var(--space-md);
  }

  .program-hero__lead {
    margin: 0;
  }

  .program-hero__topics {
    display: flex;
    flex-wrap: wrap;
    gap: var(--space-sm);
  }

  .topic-pill {
    display: inline-flex;
    align-items: center;
    justify-content: center;
    padding: 0.35rem 0.9rem;
    border-radius: 999px;
    background: rgba(93, 95, 239, 0.12);
    color: var(--color-text);
    font-size: 0.875rem;
  }

  .program-content {
    display: grid;
    gap: var(--space-md);
  }

  .program-classes {
    display: grid;
    grid-template-columns: repeat(2, minmax(0, 1fr));
    gap: var(--space-lg);
  }

  .program-classes :global(.class-card) {
    margin-bottom: 0;
    height: 100%;
  }

  .program-enroll {
    display: grid;
    gap: var(--space-lg);
    justify-items: center;
    text-align: center;
  }

  .program-enroll__text {
    display: grid;
    gap: var(--space-sm);
    font-size: 1.05rem;
    line-height: 1.6;
    max-width: clamp(30ch, 70%, 65ch);
  }

  .program-enroll__buttons {
    justify-content: center;
  }

  @media (max-width: 900px) {
    .program-classes {
      grid-template-columns: 1fr;
    }
  }

</style>