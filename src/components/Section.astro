---
import type { HTMLAttributes } from 'astro/types';

interface Props extends HTMLAttributes<'section'> {
  bgcolor?: string;
  startBgcolor?: string;
  endBgcolor?: string;
  containerClass?: string;
  sectionClass?: string;
}

const props = Astro.props as Props & { class?: string; style?: string };

const {
  bgcolor,
  startBgcolor,
  endBgcolor,
  containerClass,
  sectionClass,
  class: className,
  style: inlineStyle,
  ...rest
} = props;

// Determine the CSS classes and inline styles
const classes = ['section'];

// Add tint class if bgcolor is specified or if it's a fade
if (bgcolor || (startBgcolor && endBgcolor)) {
  classes.push('section--tint');
}

if (sectionClass) {
  sectionClass
    .split(/\s+/)
    .filter(Boolean)
    .forEach((cls) => classes.push(cls));
}

// Generate gradient or solid background style
let backgroundStyle = '';
if (startBgcolor && endBgcolor) {
  backgroundStyle = `background: linear-gradient(to bottom, ${startBgcolor}, ${endBgcolor});`;
} else if (bgcolor) {
  backgroundStyle = `background-color: ${bgcolor};`;
}

const styleParts: string[] = [];

if (backgroundStyle) {
  styleParts.push(backgroundStyle.trim().replace(/;$/u, ''));
}

if (inlineStyle && inlineStyle.trim().length > 0) {
  styleParts.push(inlineStyle.trim().replace(/;$/u, ''));
}

const styleValue = styleParts.length > 0 ? `${styleParts.join('; ')};` : undefined;

// Container classes - pass through className to container if provided
const containerClasses = ['container'];
if (className) {
  containerClasses.push(className);
}
if (containerClass) {
  containerClasses.push(containerClass);
}
---

<section class:list={classes} style={styleValue} {...rest}>
  <div class:list={containerClasses}>
    <slot />
  </div>
</section>