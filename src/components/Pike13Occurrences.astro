---
import Section from "./Section.astro";
import SectionHeader from "./SectionHeader.astro";
import { pike13_base_url, pike13_client_id } from "../content/config";
import locationsData from "../data/locations.json";

interface Props {
  serviceIds?: Array<number | string>;
  heading?: string | null;
  limit?: number;
}

const { serviceIds = [], heading = "Upcoming Sessions", limit } =
  Astro.props as Props;

function normalizeServiceIds(values: Array<number | string>): number[] {
  return Array.from(
    new Set(
      values
        .map((value) => {
          if (typeof value === "number" && Number.isFinite(value)) {
            return Math.trunc(value);
          }
          if (typeof value === "string") {
            const trimmed = value.trim();
            if (trimmed.length === 0) {
              return null;
            }
            const parsed = Number.parseInt(trimmed, 10);
            if (Number.isFinite(parsed)) {
              return Math.trunc(parsed);
            }
          }
          return null;
        })
        .filter((value): value is number => value !== null && value > 0),
    ),
  ).sort((a, b) => a - b);
}

const normalizedIds = normalizeServiceIds(serviceIds ?? []);
const baseUrlRaw = typeof pike13_base_url === "string" ? pike13_base_url.trim() : "";
const baseUrl = baseUrlRaw.replace(/\/$/, "");
const clientId = typeof pike13_client_id === "string" ? pike13_client_id.trim() : "";

const locationMap = Object.fromEntries(
  (locationsData as Array<{ id?: number; name?: string }>)
    .filter((entry) => entry && typeof entry.id === "number")
    .map((entry) => {
      const name = typeof entry.name === "string" && entry.name.trim().length > 0
        ? entry.name.trim()
        : "Location To Be Announced";
      return [String(entry.id), name];
    }),
);

const shouldRender = normalizedIds.length > 0 && baseUrl.length > 0;
const serviceIdsJson = JSON.stringify(normalizedIds);
const locationsJson = JSON.stringify(locationMap);
const limitValue = typeof limit === "number" && Number.isFinite(limit) && limit > 0 ? String(Math.trunc(limit)) : undefined;
---
{shouldRender ? (
  <Section
    class="pike13-occurrences"
    data-component="pike13-occurrences"
    data-service-ids={serviceIdsJson}
    data-base-url={baseUrl}
    data-client-id={clientId}
    data-locations={locationsJson}
    data-limit={limitValue}
  >
    {heading !== null && (
      <SectionHeader>
        <h3>{heading}</h3>
      </SectionHeader>
    )}
    <div class="pike13-occurrences__status" data-role="status">Loading upcoming sessions…</div>
    <ul class="pike13-occurrences__list" data-role="list" hidden></ul>
    <script is:inline>
      const script = document.currentScript;
      const section = script?.closest("section[data-component='pike13-occurrences']");
      if (!(section instanceof HTMLElement)) {
        console.error("Pike13Occurrences: host element not found");
      } else {
        const parseJson = (value, fallback) => {
          if (!value) {
            return fallback;
          }
          try {
            return JSON.parse(value);
          } catch (_error) {
            return fallback;
          }
        };

        const serviceIdsRaw = parseJson(section.dataset.serviceIds, []);
        const serviceIds = Array.isArray(serviceIdsRaw)
          ? serviceIdsRaw
              .map((value) => {
                const parsed = Number.parseInt(value, 10);
                return Number.isFinite(parsed) && parsed > 0 ? parsed : null;
              })
              .filter((value) => value !== null)
          : [];
        const serviceIdSet = new Set(serviceIds);

        const limitAttr = section.dataset.limit ?? "";
        const limitNumber = Number.parseInt(limitAttr, 10);
        const limitValue = Number.isFinite(limitNumber) && limitNumber > 0 ? limitNumber : null;

        const baseUrl = section.dataset.baseUrl ?? "";
        const clientId = section.dataset.clientId ?? "";
        const locations = parseJson(section.dataset.locations, {});

        const statusEl = section.querySelector('[data-role="status"]');
        const listEl = section.querySelector('[data-role="list"]');

        if (!Array.isArray(serviceIds) || serviceIds.length === 0 || !baseUrl) {
          if (statusEl) {
            statusEl.textContent = "No upcoming sessions available.";
          }
        } else {
          const formatDateTime = (isoString) => {
            if (!isoString || typeof isoString !== "string") {
              return null;
            }
            const parsed = new Date(isoString);
            if (Number.isNaN(parsed.getTime())) {
              return isoString;
            }
            try {
              return new Intl.DateTimeFormat("en-US", {
                dateStyle: "medium",
                timeStyle: "short",
                timeZone: "America/Los_Angeles",
              }).format(parsed);
            } catch (_error) {
              return parsed.toLocaleString("en-US");
            }
          };

          const fetchOccurrences = async () => {
            const perPage = limitValue ? Math.max(limitValue * 3, 12) : 100;
            const maxPages = 10;
            const start = new Date();
            start.setHours(0, 0, 0, 0);
            const end = new Date(start);
            end.setDate(start.getDate() + 7);
            end.setHours(23, 59, 59, 999);
            const startIso = start.toISOString();
            const endIso = end.toISOString();

            const occurrences = [];
            const seenIds = new Set();

            for (let page = 1; page <= maxPages; page += 1) {
              const url = new URL("/api/v2/front/event_occurrences.json", baseUrl);
              serviceIds.forEach((id) => {
                url.searchParams.append("service_ids[]", String(id));
              });
              url.searchParams.set("starts_after", startIso);
              url.searchParams.set("starts_before", endIso);
              url.searchParams.set("per_page", String(perPage));
              url.searchParams.set("page", String(page));
              if (clientId) {
                url.searchParams.set("client_id", clientId);
              }

              let payload;
              try {
                const response = await fetch(url.toString(), {
                  headers: {
                    Accept: "application/json",
                  },
                });
                if (!response.ok) {
                  break;
                }
                payload = await response.json();
              } catch (_error) {
                break;
              }

              const raw = Array.isArray(payload?.event_occurrences)
                ? payload.event_occurrences
                : Array.isArray(payload?.events)
                ? payload.events
                : Array.isArray(payload?.data)
                ? payload.data
                : Array.isArray(payload)
                ? payload
                : [];

              let received = 0;

              for (const entry of raw) {
                if (!entry || typeof entry !== "object") {
                  continue;
                }

                const rawServiceId = entry.service_id ?? entry.serviceId ?? entry.serviceID ?? null;
                const serviceId = typeof rawServiceId === "number"
                  ? Math.trunc(rawServiceId)
                  : typeof rawServiceId === "string"
                  ? Number.parseInt(rawServiceId, 10)
                  : NaN;
                if (!Number.isFinite(serviceId) || !serviceIdSet.has(serviceId)) {
                  continue;
                }

                const rawId = entry.id ?? entry.event_occurrence_id ?? entry.occurrence_id ?? null;
                const occurrenceId = typeof rawId === "number"
                  ? Math.trunc(rawId)
                  : typeof rawId === "string"
                  ? Number.parseInt(rawId, 10)
                  : NaN;
                if (Number.isFinite(occurrenceId) && seenIds.has(occurrenceId)) {
                  continue;
                }

                if (Number.isFinite(occurrenceId)) {
                  seenIds.add(occurrenceId);
                }

                const name = typeof entry.name === "string" && entry.name.trim().length > 0
                  ? entry.name.trim()
                  : null;
                const startAt = typeof entry.start_at === "string" && entry.start_at.trim().length > 0
                  ? entry.start_at.trim()
                  : null;
                const rawLocationId = entry.location_id ?? entry.locationId ?? null;
                const locationId = typeof rawLocationId === "number"
                  ? Math.trunc(rawLocationId)
                  : typeof rawLocationId === "string"
                  ? Number.parseInt(rawLocationId, 10)
                  : null;

                const staffMembers = Array.isArray(entry.staff_members) ? entry.staff_members : [];
                const instructor = staffMembers
                  .map((member) => {
                    const nameValue = member && typeof member === "object" ? member.name : null;
                    return typeof nameValue === "string" ? nameValue.trim() : "";
                  })
                  .find((value) => value.length > 0) || null;

                occurrences.push({
                  id: Number.isFinite(occurrenceId) ? occurrenceId : `${serviceId}-${startAt ?? "unknown"}-${page}-${received}`,
                  name,
                  startAt,
                  locationId: Number.isFinite(locationId) ? Math.trunc(locationId) : null,
                  instructor,
                });

                received += 1;

                if (limitValue && occurrences.length >= limitValue) {
                  break;
                }
              }

              if ((limitValue && occurrences.length >= limitValue) || received < perPage || received === 0) {
                break;
              }
            }

            occurrences.sort((a, b) => {
              const timeA = a.startAt ? Date.parse(a.startAt) : Number.POSITIVE_INFINITY;
              const timeB = b.startAt ? Date.parse(b.startAt) : Number.POSITIVE_INFINITY;
              return timeA - timeB;
            });

            return limitValue ? occurrences.slice(0, limitValue) : occurrences;
          };

          const renderOccurrences = (items) => {
            if (!listEl) {
              return;
            }

            listEl.innerHTML = "";

            items.forEach((item) => {
              const li = document.createElement("li");
              li.className = "pike13-occurrences__item";

              if (item.name) {
                const nameEl = document.createElement("p");
                nameEl.className = "pike13-occurrences__name";
                nameEl.textContent = item.name;
                li.appendChild(nameEl);
              }

              if (item.startAt) {
                const startEl = document.createElement("p");
                startEl.className = "pike13-occurrences__meta";
                const label = document.createElement("span");
                label.className = "pike13-occurrences__label";
                label.textContent = "start_at:";
                startEl.appendChild(label);
                startEl.append(" ");
                startEl.append(formatDateTime(item.startAt));
                li.appendChild(startEl);
              }

              const locationEl = document.createElement("p");
              locationEl.className = "pike13-occurrences__meta";
              const locationLabel = document.createElement("span");
              locationLabel.className = "pike13-occurrences__label";
              locationLabel.textContent = "Location:";
              locationEl.appendChild(locationLabel);
              locationEl.append(" ");
              const lookupKey = item.locationId !== null ? String(item.locationId) : null;
              const locationName = lookupKey && locations && typeof locations === "object" && lookupKey in locations
                ? locations[lookupKey]
                : "Location To Be Announced";
              locationEl.append(locationName);
              li.appendChild(locationEl);

              if (item.instructor) {
                const instructorEl = document.createElement("p");
                instructorEl.className = "pike13-occurrences__meta";
                const instructorLabel = document.createElement("span");
                instructorLabel.className = "pike13-occurrences__label";
                instructorLabel.textContent = "Instructor:";
                instructorEl.appendChild(instructorLabel);
                instructorEl.append(" ");
                instructorEl.append(item.instructor);
                li.appendChild(instructorEl);
              }

              listEl.appendChild(li);
            });

            listEl.hidden = items.length === 0;
          };

          (async () => {
            if (statusEl) {
              statusEl.textContent = "Loading upcoming sessions…";
            }

            try {
              const occurrences = await fetchOccurrences();
              if (!occurrences || occurrences.length === 0) {
                if (statusEl) {
                  statusEl.textContent = "No sessions scheduled this week.";
                }
                return;
              }

              if (statusEl) {
                statusEl.remove();
              }

              renderOccurrences(occurrences);
            } catch (error) {
              if (statusEl) {
                statusEl.textContent = "Unable to load sessions right now.";
              }
              console.error("Pike13Occurrences", error);
            }
          })();
        }
      }
    </script>
  </Section>
) : null}

<style>
  .pike13-occurrences {
    margin-top: var(--space-xl);
  }

  .pike13-occurrences__list {
    list-style: none;
    display: grid;
    gap: var(--space-lg);
    padding: 0;
    margin: 0;
  }

  .pike13-occurrences__item {
    display: grid;
    gap: var(--space-sm);
  }

  .pike13-occurrences__name {
    font-size: 1.125rem;
    font-weight: 600;
    margin: 0;
  }

  .pike13-occurrences__meta {
    margin: 0;
    color: var(--color-muted);
    font-size: 0.95rem;
  }

  .pike13-occurrences__label {
    font-weight: 600;
  }
</style>
