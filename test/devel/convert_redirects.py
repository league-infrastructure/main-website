"""Convert WordPress-style redirects into a simple pattern map."""

from __future__ import annotations

import json
import re
from datetime import datetime
from pathlib import Path

ROOT = Path(__file__).resolve().parents[2]
SOURCE = ROOT / "data" / "redirects.json"
TARGET = ROOT / "src" / "data" / "redirects.ts"

HIT_THRESHOLD = 40
LAST_ACCESS_CUTOFF = datetime(2025, 10, 1)


def load_redirects() -> list[dict[str, object]]:
    raw = json.loads(SOURCE.read_text(encoding="utf-8"))
    redirects = raw.get("redirects", [])
    if not isinstance(redirects, list):  # defensive
        raise TypeError("redirects.json does not contain a list under 'redirects'")
    return redirects


def build_pattern(entry: dict[str, object]) -> str:
    match_data = entry.get("match_data", {}) if isinstance(entry, dict) else {}
    source = match_data.get("source", {}) if isinstance(match_data, dict) else {}

    raw_path = entry.get("match_url") if isinstance(entry, dict) else None
    if not isinstance(raw_path, str) or not raw_path:
        raw_path = entry.get("url") if isinstance(entry, dict) else ""
    if not isinstance(raw_path, str):
        raise TypeError("Redirect entry is missing a usable path")
    if not raw_path.startswith("/"):
        raw_path = "/" + raw_path

    flag_case = bool(source.get("flag_case", True)) if isinstance(source, dict) else True
    flag_trailing = bool(source.get("flag_trailing", False)) if isinstance(source, dict) else False
    flag_query = source.get("flag_query", "exact") if isinstance(source, dict) else "exact"
    flag_regex = bool(source.get("flag_regex", False)) if isinstance(source, dict) else False

    if flag_regex:
        pattern = raw_path
        if not pattern.startswith("^"):
            pattern = "^" + pattern
        if not pattern.endswith("$"):
            pattern = pattern + "$"
        return pattern

    normalized = raw_path.rstrip("/") or "/"

    parts: list[str] = ["^"]
    if not flag_case:
        parts.append("(?i)")

    parts.append(re.escape(normalized))

    if normalized != "/":
        if flag_trailing:
            parts.append("/?")
        elif raw_path.endswith("/"):
            parts.append("/")

    if flag_query == "ignore":
        parts.append("(?:\\?.*)?")

    parts.append("$")
    return "".join(parts)


def _parse_last_access(value: object) -> datetime | None:
    if not isinstance(value, str):
        return None
    cleaned = value.strip()
    if not cleaned or cleaned == "-":
        return None
    for fmt in ("%B %d, %Y", "%Y-%m-%d", "%Y/%m/%d"):
        try:
            return datetime.strptime(cleaned, fmt)
        except ValueError:
            continue
    return None


def _meets_usage_threshold(entry: dict[str, object]) -> bool:
    try:
        hits = int(entry.get("hits", 0))
    except (TypeError, ValueError):
        return False
    if hits < HIT_THRESHOLD:
        return False
    last_access = _parse_last_access(entry.get("last_access"))
    if last_access is None:
        return False
    return last_access >= LAST_ACCESS_CUTOFF


def build_redirect_map(entries: list[dict[str, object]]) -> dict[str, str]:
    redirects: dict[str, str] = {}
    for entry in entries:
        if not isinstance(entry, dict):
            continue
        if not entry.get("enabled", True):
            continue
        if not _meets_usage_threshold(entry):
            continue
        action_data = entry.get("action_data", {})
        if not isinstance(action_data, dict):
            continue
        destination = action_data.get("url")
        if not isinstance(destination, str):
            continue
        pattern = build_pattern(entry)
        if pattern in redirects and redirects[pattern] != destination:
            raise ValueError(
                f"Conflicting destinations for pattern {pattern}: "
                f"{redirects[pattern]!r} vs {destination!r}"
            )
        redirects[pattern] = destination
    return redirects


def write_typescript(redirects: dict[str, str]) -> None:
    header = (
        "// This file is auto-generated by test/devel/convert_redirects.py\n"
        "// Do not edit by hand.\n\n"
    )
    lines: list[str] = [header, "export const redirects: Record<string, string> = {"]
    for pattern, destination in sorted(redirects.items(), key=lambda item: item[0]):
        key_literal = json.dumps(pattern)
        value_literal = json.dumps(destination)
        lines.append(f"  {key_literal}: {value_literal},")
    lines.append("};\n")
    TARGET.parent.mkdir(parents=True, exist_ok=True)
    TARGET.write_text("\n".join(lines), encoding="utf-8")


def main() -> None:
    entries = load_redirects()
    redirects = build_redirect_map(entries)
    write_typescript(redirects)


if __name__ == "__main__":
    main()
